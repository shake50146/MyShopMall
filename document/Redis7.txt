Redis 使用步驟
通常在linux 的/opt解壓縮 redis壓縮檔

firewall-cmd --state : 查看防火牆狀態
systemctl stop firewalld : 關閉防火牆
systemctl start firewalld : 開啟防火牆
sudo systemctl disable firewalld : 禁用防火牆服務開機自動啟動

/etc/sysctl.conf文件中
vm.overcommit_memory=1 : 內存超額配置 
sysctl vm.overcommit_memory=1 : 或是運行此命令使其生效

1. 
sudo su  使用管理員模式
mv 檔案 資料夾 : mv redis.gar /opt
tar -zxvf redis.tar.gz : 解壓縮.tar.gz檔

2.
yum -y install gcc-c++ : 安裝gcc-c++庫環境
gcc -v : 確認gcc版本

3.
make && make install :  執行make(也可以分開執行)

出現 Hint: It's a good idea to run 'make test' ;) 代表安裝成功
默認安裝的路徑在/usr/local/bin下

redis-benchmark: 性能測試工具, 服務器啟動後運行該命令, 看看自己的機器性能如何
redis-check-aof: 修復有問題的AOF文件
redis-check-rdb: 修復有問題的RDB文件
redis-cli: 客戶端, 操作入口
redis-sentinel: redis集群使用
redis-server: redis服務器啟動命令

4.在到解壓縮的地方把 redis.conf 複製一份 以免的默認配置無法還原
mkdir /myredis : 新增資料夾放複製的redis.conf
cp redis.conf /myredis/redis7.conf : 複製到資料夾並重新命名

以下是單機配置----------------------------------------------------

5.進到redis7.conf裡面修改設定
nano redis7.conf
1.默認daemonize no  	 	改為 daemonize yes
2.默認protected-mode yes  	改為 protected-mode no
3.默認bind 127.0.0.1	 	改為 直接注釋掉(默認下只能本機訪問)或改成本機IP地址, 否則影響遠程IP連接
4.requirepass foobared 添加redis密碼		 改為 requirepass 你自己設置的密碼


以下是集群配置-------------------------------------------------------------
5.port  6379			改為自己訂的port
6.dir ./ 			改為絕對路徑 /myredis (路徑自己決定)
7.pid文件名字,pidfile 進程ID可以用默認的
8.logfile "/myredis/6379.log" : log文件名字,logfile 檢查log的文件 上面還有loglevel 可以設置要抓取log的級別
9.dbfilename dump.rdb 		改為dump6379.rdb當前端口號比較好辨識
10.appendonly no 		非必須 開啟為appendonly yes 
11.533行添加replicaof IP地址 端口號	: 配置主機的對象
   541行添加masterauth "密碼"		: slave機訪問main機的配置 如果使用sentinel的話 主機也要配置從機的密碼

6.啟動redis server 先確認安裝的redis版本是不是跟環境變量的一樣 免得直接執行redis指令抓到別的版本的redis
redis-server -v : 確認server版本
nano ~/.bashrc 或 nano ~/.bash_profile : 設定環境變量
export PATH=/usr/local/bin:$PATH : 在最後一行加入這段
source ~/.bashrc 或 source ~/.bash_profile : 重新加載Shell配置 沒反應的話重開機就好了

redis-server /myredis/redis7.conf : 在/myredis啟動server 沒反應就代表一切正常

ps -ef|grep redis|grep -v grep : 查看redis 相關的進程
	ps -ef: 顯示所有進程的詳細信息。
	grep redis: 過濾包含 "redis" 字符串的行。
	grep -v grep: 排除包含 "grep" 字符串的行，以過濾掉 grep 自身的進程。

7.連接redis server
redis-cli -a 111111 -p 6379 : 111111(第5點設置的密碼) -p 6379 是默認 不寫也行
redis-cli : 啥都不寫也可以 會提示要輸入密碼
redis-cli -a 111111 -p 6379 --raw : --raw 代表對中文的支持 沒輸入的話使用redis查詢中文資料會出現亂碼

進入後輸入ping 有返回 pong 就代表連接成功

quit : 退出連接(但是沒有關閉redis-server)
shutdown : 再連接內使用關閉 再quit退出
或是在root下輸入以下方式
redis-cli -a 111111 shutdown : 單實例關閉
redis-cli -p 6379 shutdown : 多實例關閉 指定端口關閉

redis 語法--------------------------------------------------------------
set k(鍵) v(值) :設定參數
get k(鍵) v(值) :獲取參數
flushall : 清除參數


Redis 主從複製replica -------------------------------------------------------
main 負責寫 slave 負責讀

main 機上的redis7.conf 有配置requirepass參數(密碼)的話 slave機也要配置訪問main的參數
masterauth 111111 : 111111 是代表main的密碼

info replication : 可以查看複製節點的主從關係和配置信息
	配置主從關係的方法:
replicaof 主庫IP 主庫端口 : 一般寫入進redis.conf配置文件內 (配置文件法)
slaveof 主庫IP 主庫端口 : 每次與main機斷開之後, 都需要重新連接, 除非你配置進redis.conf文件 (命令操作法)
			在運行期間修改slave節點的信息, 如果該數據庫已經是某個主數據庫的從數據庫,
			那麼會停止和原主數據庫的同步關係, 轉而和新的主數據庫同步
slaveof no one : 使當前數據庫停止與其他數據庫的同步, 轉成自己當主數據庫


以下為主從複製原理和工作流程的知識點-------------------------
slave啟動, 同步出請:
	slave啟動成功連接到master後會發送一個sync同步命令
	slave首次全新連接master, 一次完全同步(全量同步)將被自動執行, slave自身原有的數據會被master覆蓋並刪除
首次連接, 全量複製
	master收到sync命令後會開始在後台保存快照(snapshot)即RDB持久化, 主從複製時會觸發RDB,同時收集所有接收到的
		用於修改數據集的命令緩存起來, master執行RDB持久化完後, master將RDB快照文件和所有緩存的命令發送		到所有slave,以完成一次完全同步
	而slave在接收到數據庫文件數據後, 將其保存並加載到內存中, 從而完成複製初始化
心跳持續, 保持通信
	repl-ping-replica-period 10 : master發出的ping包的週期, 默認是10秒(在redis.conf的670行)
進入平穩, 增量複製
	master繼續將新的所有收集到的修改命令集自動依次傳給slave, 完成同步
從機下線, 重連續傳
	master會檢查backlog裡面的offset, master和slave都會保存一個複製的offset還有一個masterId, offset是保存
	在backlog中的. master只會把已經複製的offset後面的數據複製給slave, 類似斷點續傳

主從複製的缺點-----------------------------------------------

複製延時, 信號衰減 : 
	由於所有寫操作都是在master上操作, 然後同步更新到slave上, 所以從master同步到slave會有一定的延遲, 當系統
		很忙碌的時候, 延遲問題會更加嚴重, slave機的數量增加也會使這個問題更加嚴重
master掛了 :
	默認情況下, 不會在slave中自動重選一個master


Redis 哨兵sentinel---------------------------------------------
檢查master是否故障, 如果故障了根據投票數(多台配置哨兵的機器)自動將某一個從庫轉換為新的主庫, 繼續對外服務
作用: 
	1.監控Redis運行狀態, 包括master和slave
	2.當master down機後, 能自動將slave切換成新master

配置 : 把redis壓縮檔內的sentinel.conf複製一個到/myredis下 名字不能錯
設定基本跟redis.conf一樣
bind			: 服務監聽地址, 用於客戶端連接, 默認本機地址
daemonize		: 是否以後台daemon方式運行
protected-mode		: 安全保護模式
port			: 端口
logfile			: 日誌文件路徑
pidfile			: 進程ID文件路徑
dir			: 工作目錄
sentinel monitor <master-name> <ip> <redis-port> <quorum> : 設置要監控的master服務器
sentinel auth-pass <master-name> <password> : master設置了密碼, 連接master服務的密碼

其他配置 :
sentinel down-after-milliseconds <master-name> <milliseconds> : 指定多少毫秒後, master沒有應答哨兵, 此時
	哨兵主觀上認為master下線 默認30秒
sentinel parallel-syncs <master-name> <nums> : 表示允許並行同步的slave個數, 當master掛了後, 哨兵會選出新的
	master, 此時剩餘的slave會向新的master發起同步數據
sentinel failover-timeout <master-name> <milliseconds> : 故障轉移的超時時間, 進行故障轉移時, 如果超過設置的
	毫秒, 表示故障轉移失敗
semtinel notification-script <master-name> <script-path> : 配置當某一個事件發生時所需要執行的腳本
sentinel client-reconfig-script <master-name> <script-path> : 客戶端重新配置master的參數腳本

quorum : 表示最少有幾個哨兵認可客觀下線,同意故障遷移的法定票數
	有時候一個sentinel會因為網路堵塞而誤以為一個master redis已經死掉了, 在sentinel集群環境下需要多個
	sentinel互相溝通來確認某個master是否真的死了, quorum這個參數就是進行客觀下線的一個依據, 意思是至少有
	quorum個sentinel認為這個master有故障, 才會對這個master進行下線以及故障轉移. 這就保證了公平性和高可用

在/myredis下新建一個sentinel26379.conf配置類配置哨兵用的配置類
nano sentinel26379.conf : 沒有相關檔案就等於創建

參數設定:
bind 0.0.0.0
daemonize yes
protected-mode no
port 26379
logfile "/myredis/sentinel26379.log"
pidfile /var/run/resid-sentinel26379.pid
dir /myredis
sentinel monitor mymaster 192.168.93.128 6379 2
sentinel auth-pass mymaster 111111

啟動哨兵機器:
redis-sentinel /path/to/sentinel.ocnf  : /oath/to/sentinel.conf 代表你放配置類的位置
redis-server /path/to/sentinel.conf --sentinel

在master斷開之後, slave會需要重連而跳出兩個小問題, 在輸入一次才會正常
	Error: Server closed the connection : 兩種都有機會出現
	Error: Broken pipe 
意思是: 對端的管道已經斷開, 都發生在遠端把這個讀/寫管道關閉了, 你無法在對這個管道進行讀寫操作

結論: 主從redis.conf 文件的內容, 在運行期間會被sentinel動態進行更改
	master-slave切換後, master-redis.conf , slave-redis.conf和sentinel.conf的內容都會發生改變,
	即master-redis.conf中會多一行slaveof的配置, sentinel.conf的監控目標會隨之調換

哨兵的運行流程和選舉原理: 
	當一個主從配置中的master失效後, sentinel可以選舉出一個新的master用於自動接替原master的工作, 
	主從配置中的其他redis服務器自動指向新的master同步數據. 
	一般建議sentinel採取奇數台, 防止某一台sentinel無法連接到mater導致誤切換
運行流程, 故障切換:
	SDown主觀下線(Subjectively Down) : 是單個sentinel自己主觀上檢測到的關於master的狀態, 從sentinel的
		角度來看, 如果發送了ping心跳後, 在一定時間內沒有收到合法的回覆, 就到達了SDOWN的條件
	ODown客觀下線(Objectively Down) : 需要一定數量的sentinel, 多個哨兵達成一致意見才能認為一個master
		客觀上已經當掉
	選舉出領導者哨兵(哨兵中選出哨兵王) : 當master被判斷客觀下線以後, 各個哨兵節點會進行協商, 先選舉出
		一個領導者哨兵並由該領導者進行failover(故障遷移)
	選出領導者哨兵是使用 : Raft算法

	由哨兵王開始推動故障切換流程並選出一個新master
	三步驟:
	1.新主登基
		選出新master的規則, 剩餘slave的健康前提下 :  以下順序往下決定 
			1.redis.conf文件中, 優先級slave-priority或者replica-priority最高的slave(數字越小優先級越高)
			2.複製偏移位置offset最大的slave
			3.Run ID最小的slave
	2.群臣俯首
		執行slaveof no one 命令讓選出來的slave成為新的master, 並通過slaveof命令讓其他節點成為其slave
		sentinel leader會對選舉出的新master執行slaveof no ont操作, 將其提升為master
		sentinel leader向其他slave發送slaveof命令, 讓剩餘的slave成為新的master的slave
	3.舊主拜服	
		將之前已經下線的老master設置為新選出的新master的slave, 當老master重新上線後, 他會成為新master
			的slave
		sentinel leader會讓原來的master降級為slave並恢復正常工作

小總結: 
	上述的failover操作均由sentinel自己獨力完成, 完全無需人工干預
		
哨兵使用建議:
1.哨兵節點的數量應為多個, 哨兵本身應該級群, 保證高可用
2.哨兵節點的數量應該是奇數
3.各個哨兵節點的配置應一致
4.如果哨兵節點部屬在Docker等容器裡面, 尤其要注意端口的正確映射
5.哨兵集群+主從複製, 並不能保證數據零丟失, 而引出集群

Redis 集群cluster----------------------------------------------

Redis集群是一個提供在多個Redis節點間共享數據的程序集
Redis集群可以支持多個master , 每個master又可以掛載多個slave : 讀寫分離/支持數據的高可用/支持海量數據得讀寫存操作
由於cluster自帶sentinel的故障轉移機制, 內置了高可用的支持, 無須再去使用哨兵功能
客戶端與Redis的節點連接, 不再需要連接集群中所有的節點, 只需要任意連接集群中的一個可用節點即可
槽位slot負責分配到各個物理服務節點, 由對應的集群來負責維護節點,槽位和數據之間的關係

集群算法-分片-槽位slot-----------------
槽位slot:
Key distribution model
The cluster's key space is split into 16384 slots, effectively setting an upper limit for the cluster size of 16384 master nodes (however, the suggested max size of nodes is on the order of ~ 1000 nodes).

Redis集群沒有使用一致性hash, 而是引入了哈希槽的概念
Redis集群有16384個哈希槽, 每個key通過CRC16校驗後對16384取模來決定放置哪個槽, 集群的每個節點負責一部份hash槽
	比如當前集群有3個節點 那麼 : 節點一負責0-5460 slot 節點二負責5461-10922 slot 節點三負責10923-16383

分片:
使用Redis集群時我們會將存儲的數據分散到多台redis機器上, 這稱為分片. 簡言之, 集群中的每個Redis實例都被認為是整
	個數據的一個分片
如何找到給定的key的分片:
為了找到給定key的分片, 我們對key進行CRC16(key)算法處理並通過對總分片數量取模. 然後, 使用確定性哈希函數
	這意味著給定的key將多次始終映射到同一個分片, 我可以推斷將來讀取特定key的位置

優勢: 方便擴縮容和數據分派查找

槽位映射 一般有3種解決方案:
1.哈希取餘分區 : 缺點:分母按照節點變動 對節點數取餘 擴縮容不便 容易造成存儲問題
2.一致性哈希算法分區 : 分母固定以解決取餘缺點
	三大步驟:
	算法構建一致性哈希環 : 一個圓表示1~2^32  對2^32取餘 
	服務器IP節點映射 : 將集群中各個IP節點映射到環上的某一個位置 使用hash算法
	key落到服務器的落鍵規則 : 對key計算hash值, 並放在環的相對應位置上, 按照順時針行走遇到的第一台服務器就是		定位到的服務器, 並將該鍵值對存儲在該節點上
	優點:
	容錯性: 假設abcd四個服務器 c掛了,不會影響到a b d, 只會影響到b,c之間的數據 並轉移到d進行存儲
	擴展性: 增加一台x到a b之間, 那只會影響a到x之間的數據 重新把a到x之間的數據存儲到x即可

	缺點:
	hash環的數據傾斜問題: 節點太少時, 容易因為節點分布不均勻而造成數據傾斜(大部分都集中到某一台服	務器上)
	
3.哈希槽分區
	哈希槽實質就是一個數組, [0,2^14]形成hash slot空間 剛好就是16384

	就是 HASH_SLOT = CRC16(key) mod 16384
	Redis集群中內置了16384個哈希槽, redis會根據節點數量大致均等的將哈希槽映射到不同的節點. 當需要在Redis集群	中放置一個key-value十, redis先對key使用crc16算法算出一個結果然後用結果對16384求餘數
	[CRC16(key) % 	16384]. 這樣每個key都會對應一個編號在0-16383之間的哈希槽, 也就是映射到某個節點上

	為什麼redis集群的最大槽數是16384? : github上有 https://github.com/redis/redis/issues/2576
		1.如果槽位為65536, 發送心跳信息的消息頭就會達8k, 發送的心跳包過於龐大
		2.redis的集群主節點數量基本不可能超過1000個
		3.槽位越小, 節點少的情況下, 壓縮比高, 容易傳輸
	
Redis集群不保證強一致性, 這意味著在特定的條件下, Redis集群可能會丟掉一些被系統收到的寫入請求命令


環鍵搭建---------------------------------------------------------

3主3從Redis集群配置------------------

bind 0.0.0.0
daemonize yes
protected-mode no
port 6379
logfile "/myredis/cluster/cluster6379.log"
pidfile /myredis/cluster6379.pid
dir /myredis/cluster
dbfilename dump6379.rdb
appendonly yes
appendfilename "appendonly6379.aof"
requirepass 111111
masterauth 111111

cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 5000

集群設定
cluster-enabled yes				: 打開集群
cluster-config-file nodes-6379.conf		: 集群的配置文件名稱
cluster-node-timeout 5000			: 集群之間的超時時間

全部都是一樣配置, 配置完後開啟六個redis機台
通過redis-cli命令為6台機器構建集群關係 : 在哪一台輸入都沒關係

redis-cli -a 111111 --cluster create --cluster-replicas 1 192.168.93.128:6379 192.168.93.128:6380 192.168.93.129:6381 192.168.93.129:6382 192.168.93.130:6383 192.168.93.130:6384
	解說: --cluster-replicas 1 : 表示為每個master創建一個slave節點

輸入完之後要確認才會創建 : yes

集群創建成功一定會產生nodes開頭的檔案

集群指令:
cluster info : 查看集群的設定
cluster nodes : 查看集群節點的關係
cluster keyslot key : 查看key的槽位slot
cluster failover : 節點主從調整回原本設定
cluster countkeysinslot slotnumber : 檢查該槽位是否被占用

3主3從Redis集群讀寫----------------------
以集群方式進入節點進行讀寫操作需要在命令行後面加一個 -c 
redis-cli -a 111111 -p 6379 -c : -c代表進入集群路由 不寫只會進入單個節點的槽位

容錯切換遷移: 集群的主從關係切換方式跟哨兵是一樣的 

手動故障轉移 or 節點從屬調整: cluster failover


3主3從Redis集群擴容4主4從----------------------

啟動要擴容的節點 此時沒有加入集群 都還是master :
redis-server /myredis/cluster/redisCluster6385.conf
redis-server /myredis/cluster/redisCluster6386.conf

將新增的6385節點(空槽號)作為master加入原集群 :
redis-cli -a 111111 --cluster add-node 加入集群的IP:端口 目標集群的IP:端口
redis-cli -a 111111 --cluster add-node 192.168.93.128:6385 192.168.93.128:6379

第一次檢查集群的狀況:
redis-cli -a 111111 --cluster check 192.168.93.128:6379

重新分派槽位: 因為新加入的master節點是位分配槽位的狀態 需要重新分配 
redis-cli -a 111111 --cluster reshard 192.168.93.128:6379

重點: 執行重新分配指令時
	1. How many slots do you want to move (from 1 to 16384?) :
	指令輸入後會要求你輸入要給新master節點的槽位數量, 真實數量就以16384除當前集群的master槽位數量
	2. What is the receiving node ID? :
	需要輸入新master的節點ID: dab6fbd30660e9c9233eef16bdd2c163e2f808e3 (實際情況每人不一樣)
	3. Source node #1:
	輸入 all 就好
	4. Do you want to proceed with the proposed reshard plan (yes/no)?:
	同意重新分配 yes

再進行第二次檢查集群的狀況: 確認槽位分配是否成功
redis-cli -a 111111 --cluster check 192.168.93.128:6379

新master槽位的分配方式: 以前一起創建的3個槽是連續的 新擴容的則是斷斷續續的
	因為重新分配成本太高, 所以前3個槽6379/6381/6383各自分配一部分給新master槽位

為新master節點6385分配從節點6386:
redis-cli -a 111111 --cluster add-node 新slave的IP:端口 新master的IP:端口 --cluster-slave --cluster-master-id 新主機節點ID

redis-cli -a 111111 --cluster add-node 192.168.93.128:6386 192.168.93.128:6385 --cluster-slave --cluster-master-id dab6fbd30660e9c9233eef16bdd2c163e2f808e3


4主4從Redis集群縮容3主3從----------------------

步驟:
1.先清除從節點6386
2.清出來的槽號重新分配給6379
3.再刪除6385
4.恢復成3主3從

第一次檢查集群的狀況: 先獲得從節點6386的節點ID
redis-cli -a 111111 --cluster check 192.168.93.128:6386

從集群中將4號節點6386刪除:
redis-cli -a 111111 --cluster del-node 要刪除的slave的IP:端口 要刪除的slave節點ID
redis-cli -a 111111 --cluster del-node 192.168.93.128:6386 761c71d6c2c2b8b475a752a6c196cb540bcde45a

將6385的槽號清空, 重新分配, 本例將清出來的槽號都還給6379:
redis-cli -a 111111 --cluster reshard 192.168.93.128:6379

重點: 執行重新分配指令時
	1. How many slots do you want to move (from 1 to 16384?) :
	將6385節點的槽數量都給6379 所以有 4096個
	2. What is the receiving node ID? :
	輸入要接收槽位的節點ID: 53eba60179d43dee6f66afad83502e67eeb12fee (實際情況每人不一樣)
	3. Source node #1:
	輸入要給出槽位的節點ID: dab6fbd30660e9c9233eef16bdd2c163e2f808e3
	4. Source node #2:
	輸入done
	5. Do you want to proceed with the proposed reshard plan (yes/no)?:
	同意重新分配 yes

第二次檢查集群的狀況: 原來的master:6385 變成6379的slave了
redis-cli -a 111111 --cluster check 192.168.93.128:6379


將6386從集群中刪除:
redis-cli -a 111111 --cluster del-node 192.168.93.128:6385 dab6fbd30660e9c9233eef16bdd2c163e2f808e3

第三次檢查集群的狀況: 檢查6385/6386被徹底刪除了
redis-cli -a 111111 --cluster check 192.168.93.128:6379

槽位傾斜可以使用 --cluster rebalance重新分配槽位
redis-cli -a 111111 --cluster rebalance 192.168.93.128:6379 : 重新分配槽位 只要輸入集群內其中一個master就好

集群的知識點: -------------------------------------------------------
1.不在同一個slot槽位下的多件操作(mset,mget等多鍵操作)無法支持, 要使用通識站位符
	可以通過{}來定義同一個組的概念, 使用key中{}內相同內容的鍵值對放到一個slot槽位去, 如k1k2k3都映射為x
		自然槽位都一樣
mset k1{z} z1 k2{z} z2 k3{z} z3
mget k1{z} k2{z} k3{z}

2.CRC源碼淺談: 可以看cluster.c源碼分析  (C語言的源碼)

3.常用命令:
	1.集群是否完整才能對外提供服務 : cluster-require-full-coverage
		在redis-conf設定的 在比如3主3從集群中1主1從突然失效變2主2從, 可以設置是否要對外暴露提供服務
			默認值為yes
	2.cluster countkeysinslot 槽位數字編號 :  cluster countkeysinslot 0-16384
		在redis-cli 裡面使用 檢查該槽位是否被占用 跟map的hash值放值一樣意思
	3.cluster keyslot 鍵名稱 : 
		在redis-cli 裡面使用 查看key的槽位slot

使用spring Boot 集成redis------------------------------------------------

當集群的其中一個master當機後, 其slave上位成為master, 在redis下可以正常執行, 但是在spring boot端就會出錯:
exception is io.lettuce.core.RedisCommandTimeoutException: Command timed out after 1 minute(s) with root cause

nested exception is io.lettuce.core.RedisConnectionException: Unable to connect to 192.168.93.128 with root cause

導致原因是spring boot 2.X版本, Redis默認的連接值採用Lettuce, 當Redis集群節點發生變化後, Lettuce默認是不會刷新節點拓扑

解決方案:
1.排除lettuce采用Jedis（不推荐）
2.重写连接工厂实例（极度不推荐）
3.刷新节点集群拓扑动态感应:
	调用 RedisClusterClient.reloadPartitions
	后台基于时间间隔的周期刷新
	后台基于持续的 断开 和 移动、重定向 的自适应更新

spring boot 3.1.5版本使用不會出錯, 代表以改善

